import pickle

from zeroband.inference.rewards import CompletionReward, RequestRewards, compute_rewards


# Mika: This is a somewhat brittle test that simply checks whether the reward
# computation is correct for some fixed pickled input and output. If this test
# fails, this could mean that you *broke* or *fixed* the reward computation.
# The only thing you know for sure, is that something is computed differently.
# The file is generated by inserting this block of code after the reward computation:
# ```
# import pickle
#
# with open("rewards.pkl", "wb") as f:
#     pickle.dump(
#         {
#             "request_outputs": request_outputs,
#             "verification_infos": verification_infos,
#             "task_types": task_types,
#             "config": config.len_rewards,
#             "rewards": rewards,
#             "task_rewards": task_rewards,
#             "length_penalties": length_penalties,
#             "advantages": advantages,
#         },
#         f,
#     )
# ```
def test_compute_rewards():
    # Load precomputed rewards
    with open("tests/unit/inference/rewards.pkl", "rb") as f:
        precomputed_rewards = pickle.load(f)
    # Get inputs and outputs
    request_outputs = precomputed_rewards["request_outputs"]
    verification_infos = precomputed_rewards["verification_infos"]
    task_types = precomputed_rewards["task_types"]
    config = precomputed_rewards["config"]
    ground_truth_rewards = precomputed_rewards["rewards"]
    ground_truth_task_rewards = precomputed_rewards["task_rewards"]
    ground_truth_length_penalties = precomputed_rewards["length_penalties"]
    ground_truth_advantages = precomputed_rewards["advantages"]

    # Re-compute rewards
    task_types = ["verifiable_math"] * len(request_outputs)
    request_rewards = compute_rewards(request_outputs, verification_infos, task_types, config)

    assert all(isinstance(request_reward, RequestRewards) for request_reward in request_rewards)

    # Assert type
    for request_reward in request_rewards:
        for completion_reward in request_reward.rewards:
            assert isinstance(completion_reward, CompletionReward)
            print(type(completion_reward.advantage))
            assert isinstance(completion_reward.advantage, float)

    grouped_rewards = {
        request_reward.request_id: [reward.reward for reward in request_reward.rewards] for request_reward in request_rewards
    }
    grouped_task_rewards = {
        request_reward.request_id: [reward.task_reward for reward in request_reward.rewards] for request_reward in request_rewards
    }
    grouped_length_penalties = {
        request_reward.request_id: [reward.length_penalty for reward in request_reward.rewards] for request_reward in request_rewards
    }
    grouped_advantages = {
        request_reward.request_id: [reward.advantage for reward in request_reward.rewards] for request_reward in request_rewards
    }

    # Assert computation
    assert grouped_rewards == ground_truth_rewards
    assert grouped_task_rewards == ground_truth_task_rewards
    assert grouped_length_penalties == ground_truth_length_penalties
    assert grouped_advantages == ground_truth_advantages
